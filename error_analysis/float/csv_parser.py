#!/usr/bin/env python3
"""
CSV Parser for QCD Loop Error Analysis Data

This script parses two types of CSV files generated by boxGPU_test.cc:
- box_run_1.csv: Complex coefficients stored as hex values (double precision)
- box_run_0.csv: Complex coefficients stored as quad precision decimal values
"""

import csv
import struct
import re
from typing import List, Dict, Any, Tuple, Union


class ParsedRow:
    """Data class to hold parsed row data"""
    def __init__(self, target_integral, test_id, mu2, ms, ps, coeff1, coeff2, coeff3):
        self.target_integral = target_integral
        self.test_id = test_id
        self.mu2 = mu2
        self.ms = ms
        self.ps = ps
        self.coeff1 = coeff1
        self.coeff2 = coeff2
        self.coeff3 = coeff3
        
        # Extract real and imaginary parts for easy access
        self.coeff1_real = coeff1.real
        self.coeff1_imag = coeff1.imag
        self.coeff2_real = coeff2.real
        self.coeff2_imag = coeff2.imag
        self.coeff3_real = coeff3.real
        self.coeff3_imag = coeff3.imag
    
    def __repr__(self):
        return (f"ParsedRow(target_integral='{self.target_integral}', "
                f"test_id={self.test_id}, mu2={self.mu2}, ms={self.ms}, "
                f"ps={self.ps}, coeff1={self.coeff1}, coeff2={self.coeff2}, "
                f"coeff3={self.coeff3})")
    
    def print_coefficients(self, format_type="auto"):
        """Print coefficients with full precision real and imaginary parts
        
        Args:
            format_type: "hex" for padded double precision, "quad" for quad precision, "auto" to detect
        """
        if format_type == "auto":
            # Determine format based on the precision of the values
            # Quad precision values typically have more trailing digits
            if hasattr(self, '_format_type'):
                format_type = self._format_type
            else:
                format_type = "quad"  # Default to quad precision format
        
        if format_type == "hex":
            # Pad double precision to match quad precision display (33 decimal places)
            print(f"Coeff1 Real:  {self.coeff1_real:.33f}")
            print(f"Coeff1 Imag: {self.coeff1_imag:.33f}")
            print(f"Coeff2 Real:  {self.coeff2_real:.33f}")
            print(f"Coeff2 Imag: {self.coeff2_imag:.33f}")
            print(f"Coeff3 Real:  {self.coeff3_real:.33f}")
            print(f"Coeff3 Imag: {self.coeff3_imag:.33f}")
        else:  # quad precision
            print(f"Coeff1 Real:  {self.coeff1_real:.33f}")
            print(f"Coeff1 Imag: {self.coeff1_imag:.33f}")
            print(f"Coeff2 Real:  {self.coeff2_real:.33f}")
            print(f"Coeff2 Imag: {self.coeff2_imag:.33f}")
            print(f"Coeff3 Real:  {self.coeff3_real:.33f}")
            print(f"Coeff3 Imag: {self.coeff3_imag:.33f}")


class QCDLoopCSVParser:
    """Parser for QCD Loop CSV files with different coefficient formats"""
    
    def __init__(self):
        # Pattern for hex format: (0x...,0x...)
        self.hex_pattern = re.compile(r'\(0x([0-9a-fA-F]+),0x([0-9a-fA-F]+)\)')
        # Pattern for quad precision format: (real,imag) with scientific notation
        self.quad_pattern = re.compile(r'\(([+-]?[\d.]+e?[+-]?\d*),([+-]?[\d.]+e?[+-]?\d*)\)')
    
    def parse_list_string(self, list_str: str) -> List[float]:
        """Parse a string representation of a list like '[1,2,3,4]' into a list of floats"""
        # Remove brackets and split by comma
        content = list_str.strip('[]')
        if not content:
            return []
        return [float(x.strip()) for x in content.split(',')]
    
    def hex_to_double(self, hex_str: str) -> float:
        """Convert hex string to float (auto-detects single vs double precision)"""
        # Remove 0x prefix and convert to int
        hex_value = int(hex_str, 16)
        
        # Convert to float
        if hex_value == 0:
            return 0.0
        
        # Check if this is a 32-bit (8 hex digits) or 64-bit (16 hex digits) value
        hex_digits = hex_str.replace('0x', '').replace('0X', '')
        
        if len(hex_digits) <= 8:  # 32-bit single precision
            # Pack as 4-byte unsigned int and unpack as float
            packed = struct.pack('I', hex_value)
            return struct.unpack('f', packed)[0]
        else:  # 64-bit double precision
            # Pack as 8-byte unsigned long long and unpack as double
            packed = struct.pack('Q', hex_value)
            return struct.unpack('d', packed)[0]
    
    def parse_hex_complex(self, complex_str: str) -> complex:
        """Parse complex number from hex format: (0x...,0x...)"""
        match = self.hex_pattern.match(complex_str.strip())
        if not match:
            raise ValueError(f"Invalid hex complex format: {complex_str}")
        
        real_hex, imag_hex = match.groups()
        real_part = self.hex_to_double(real_hex)
        imag_part = self.hex_to_double(imag_hex)
        
        return complex(real_part, imag_part)
    
    def parse_quad_complex(self, complex_str: str) -> complex:
        """Parse complex number from quad precision decimal format: (real,imag)"""
        match = self.quad_pattern.match(complex_str.strip())
        if not match:
            raise ValueError(f"Invalid quad complex format: {complex_str}")
        
        real_str, imag_str = match.groups()
        real_part = float(real_str)
        imag_part = float(imag_str)
        
        return complex(real_part, imag_part)
    
    def split_csv_line_with_complex_numbers(self, line: str) -> List[str]:
        """Split a CSV line handling commas in complex numbers and lists"""
        fields = []
        current_field = ""
        paren_depth = 0
        bracket_depth = 0
        
        i = 0
        while i < len(line):
            char = line[i]
            
            if char == '(':
                paren_depth += 1
                current_field += char
            elif char == ')':
                paren_depth -= 1
                current_field += char
            elif char == '[':
                bracket_depth += 1
                current_field += char
            elif char == ']':
                bracket_depth -= 1
                current_field += char
            elif char == ',' and paren_depth == 0 and bracket_depth == 0:
                fields.append(current_field.strip())
                current_field = ""
            else:
                current_field += char
            
            i += 1
        
        # Add the last field
        if current_field.strip():
            fields.append(current_field.strip())
        
        return fields
    
    def parse_row(self, row: List[str], is_hex_format: bool = True) -> ParsedRow:
        """Parse a single CSV row into a ParsedRow object"""
        if len(row) != 8:
            raise ValueError(f"Expected 8 columns, got {len(row)}")
        
        target_integral = row[0]
        test_id = int(row[1])
        mu2 = float(row[2])
        ms = self.parse_list_string(row[3])
        ps = self.parse_list_string(row[4])
        
        # Parse complex coefficients based on format
        if is_hex_format:
            coeff1 = self.parse_hex_complex(row[5])
            coeff2 = self.parse_hex_complex(row[6])
            coeff3 = self.parse_hex_complex(row[7])
        else:
            coeff1 = self.parse_quad_complex(row[5])
            coeff2 = self.parse_quad_complex(row[6])
            coeff3 = self.parse_quad_complex(row[7])
        
        parsed_row = ParsedRow(
            target_integral=target_integral,
            test_id=test_id,
            mu2=mu2,
            ms=ms,
            ps=ps,
            coeff1=coeff1,
            coeff2=coeff2,
            coeff3=coeff3
        )
        
        # Set format type for proper display
        parsed_row._format_type = "hex" if is_hex_format else "quad"
        
        return parsed_row
    
    def parse_csv_file(self, filepath: str, is_hex_format: bool = True) -> List[ParsedRow]:
        """Parse an entire CSV file and return list of ParsedRow objects"""
        rows = []
        
        with open(filepath, 'r', newline='', encoding='utf-8') as csvfile:
            # Use custom parsing for both formats since both have commas in complex numbers
            lines = csvfile.readlines()
            
            # Skip header
            for line_num, line in enumerate(lines[1:], start=2):
                line = line.strip()
                if not line:
                    continue
                
                try:
                    # Split the line using custom logic for complex numbers
                    row = self.split_csv_line_with_complex_numbers(line)
                    if len(row) != 8:
                        print(f"Warning: Skipping row {line_num} in {filepath}: Expected 8 columns, got {len(row)}")
                        continue
                    
                    parsed_row = self.parse_row(row, is_hex_format)
                    rows.append(parsed_row)
                except Exception as e:
                    print(f"Warning: Error parsing row {line_num} in {filepath}: {e}")
                    continue
        
        return rows
    
    def parse_box_run_1(self, filepath: str) -> List[ParsedRow]:
        """Parse box_run_1.csv (hex format)"""
        return self.parse_csv_file(filepath, is_hex_format=True)
    
    def parse_box_run_0(self, filepath: str) -> List[ParsedRow]:
        """Parse box_run_0.csv (quad precision format)"""
        return self.parse_csv_file(filepath, is_hex_format=False)


def main():
    """Example usage of the CSV parser"""
    parser = QCDLoopCSVParser()
    
    # Parse both files
    print("Parsing box_run_1.csv (hex format)...")
    try:
        box_run_1_data = parser.parse_box_run_1('box_run_1.csv')
        print(f"Successfully parsed {len(box_run_1_data)} rows from box_run_1.csv")
        
        # Print first few rows as example
        print("\nFirst 3 rows from box_run_1.csv:")
        for i, row in enumerate(box_run_1_data[:3]):
            print(f"Row {i+1}:")
            print(f"  Target Integral: {row.target_integral}")
            print(f"  Test ID: {row.test_id}")
            print(f"  mu2: {row.mu2}")
            print(f"  ms: {row.ms}")
            print(f"  ps: {row.ps}")
            print(f"  Coeff1: {row.coeff1}")
            print(f"  Coeff2: {row.coeff2}")
            print(f"  Coeff3: {row.coeff3}")
            print("  Coefficient details:")
            row.print_coefficients()
            print()
    
    except Exception as e:
        print(f"Error parsing box_run_1.csv: {e}")
    
    print("Parsing box_run_0.csv (quad precision format)...")
    try:
        box_run_0_data = parser.parse_box_run_0('box_run_0.csv')
        print(f"Successfully parsed {len(box_run_0_data)} rows from box_run_0.csv")
        
        # Print first few rows as example
        print("\nFirst 3 rows from box_run_0.csv:")
        for i, row in enumerate(box_run_0_data[:3]):
            print(f"Row {i+1}:")
            print(f"  Target Integral: {row.target_integral}")
            print(f"  Test ID: {row.test_id}")
            print(f"  mu2: {row.mu2}")
            print(f"  ms: {row.ms}")
            print(f"  ps: {row.ps}")
            print(f"  Coeff1: {row.coeff1}")
            print(f"  Coeff2: {row.coeff2}")
            print(f"  Coeff3: {row.coeff3}")
            print("  Coefficient details:")
            row.print_coefficients()
            print()
    
    except Exception as e:
        print(f"Error parsing box_run_0.csv: {e}")


if __name__ == "__main__":
    main()